Dans le cadre de mon stage chez la Société Générale, j'ai été introduit à plusieurs pratiques essentielles de développement logiciel, notamment les tests unitaires et l'intégration continue. Ces pratiques sont cruciales pour garantir la qualité et la fiabilité du code, en particulier dans des environnements de production critiques comme ceux de la Société Générale. J'ai eu l'occasion de mettre en œuvre ces concepts en travaillant sur des scripts de gestion des transit gateways dans AWS.

### Environnement de Travail

Mon environnement de travail était composé d'un ordinateur portable sur lequel étaient installés des outils essentiels tels que Visual Studio Code (VSCode) pour l'édition de code, GitHub pour la gestion des versions et la collaboration, ainsi qu'un compte AWS pour accéder aux services cloud. Cette configuration m'a permis de développer, tester et déployer des scripts de manière efficace et collaborative.

### Vulgarisation des Tests Unitaires

Les tests unitaires sont des tests automatisés qui permettent de vérifier que des portions spécifiques du code fonctionnent comme prévu. Dans notre cas, nous avons écrit des tests unitaires pour les principales fonctions de notre script AWS, en utilisant le framework `unittest` de Python. 

1. **Test de get_caller_identity** : Cette fonction interroge AWS pour obtenir l'identité de l'appelant (c'est-à-dire le compte AWS en cours d'utilisation). Pour tester cette fonction, nous avons utilisé un "mock" pour simuler la réponse du service AWS STS. Le mock permet de remplacer le comportement réel par un comportement simulé afin de tester comment notre code réagit à différentes réponses. Nous avons vérifié que la fonction renvoie l'identifiant de compte correct, ce qui est essentiel pour que les opérations suivantes soient effectuées dans le bon contexte de compte AWS.

2. **Test de get_route_table_id** : Cette fonction cherche l'identifiant de la table de routage associée à un transit gateway spécifique. Nous avons simulé la réponse de l'API AWS EC2 pour nous assurer que notre fonction extrait correctement l'identifiant de la table de routage. Cela garantit que nous pouvons localiser et gérer les tables de routage nécessaires pour nos opérations réseau.

3. **Test de get_route_tables** : Cette fonction récupère les routes définies dans une table de routage spécifique. En simulant les réponses de l'API AWS, nous avons pu vérifier que notre fonction retourne les routes attendues. Cela nous permet de nous assurer que les données de routage que nous récupérons sont complètes et exactes.

### Mise en Place d'une GitHub Action

Pour automatiser l'exécution de nos tests et garantir que notre code reste fiable au fil du temps, nous avons mis en place une GitHub Action. Les GitHub Actions sont des workflows automatisés qui s'exécutent en réponse à des événements dans un dépôt GitHub, comme un push de code ou une pull request. Voici comment nous avons structuré cette action :

1. **Configuration du Workflow** : Nous avons créé un fichier de configuration YAML dans lequel nous avons défini les étapes de notre pipeline d'intégration continue. Cela incluait l'installation des dépendances Python nécessaires, l'exécution des tests unitaires, et la génération de rapports sur les résultats des tests.

2. **Déclenchement Automatique** : Chaque fois qu'un nouveau code est poussé sur le dépôt ou qu'une demande de fusion est créée, la GitHub Action est automatiquement déclenchée. Cela garantit que chaque modification du code est testée immédiatement, réduisant ainsi le risque d'introduire des bugs.

3. **Feedback en Temps Réel** : Si un test échoue, la GitHub Action fournit un retour instantané, indiquant précisément quelle partie du code a échoué et pourquoi. Cela permet aux développeurs de corriger rapidement les erreurs et d'améliorer la qualité du code.

### Conclusion

En utilisant les tests unitaires et les GitHub Actions, nous avons pu garantir la fiabilité et la stabilité de notre code de gestion des transit gateways. Cette expérience m'a permis de comprendre l'importance des bonnes pratiques en développement logiciel et de les appliquer dans un contexte professionnel réel. J'ai appris à écrire des tests unitaires efficaces, à simuler des réponses d'API pour tester différentes conditions, et à automatiser le processus de test pour une intégration continue fluide. Ces compétences seront inestimables dans ma carrière future, en me permettant de développer des logiciels robustes et fiables tout en travaillant de manière collaborative et efficace.
